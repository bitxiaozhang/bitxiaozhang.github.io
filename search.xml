<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发的一些实用命令.md]]></title>
    <url>%2F2020%2F03%2F18%2FAndroid%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、测试启动Activity的启动时间，可以大概判断应用的启动性能：1adb shell am start -S -R 10 -W com.xxx.xxx/xxx.xx.StartActivity 2、查看应用运行的内存情况, 查看activity的释放情况1adb shell dumpsys meminfo com.xxx.xxx[package] 3、清理app数据，免得去应用设置中去清理数据1adb shell pm clear com.xxx.xxx[package] 4、查看项目中某个module的依赖树1./gradlew moduleName:dependencies]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>adb</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac node升级到最新版本]]></title>
    <url>%2F2020%2F01%2F09%2FMac-node%E5%8D%87%E7%BA%A7%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[第一步，先查看本机node.js版本： 1node -v 第二步，清除node.js的cache： 1sudo npm cache clean -f 第三步，安装 n 工具，这个工具是专门用来管理node.js版本的，别怀疑这个工具的名字，是他是他就是他，他的名字就是 “n” 1sudo npm install -g n 第四步，安装最新版本的node.js 1sudo n stable 第五步，再次查看本机的node.js版本： 1node -v 第六步，更新npm到最新版： 1$ sudo npm install npm@latest -g 第七步，验证 12node -vnpm -v]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android滑动解锁]]></title>
    <url>%2F2017%2F06%2F27%2FAndroid%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81%2F</url>
    <content type="text"><![CDATA[通过android自定义View实现横向的滑动解锁，1、滑动到中间会自动返回到原始的位置，2、滑动到底部会自动解锁，会触发解锁的回调；首先看效果图如下： 实现以上部分一共分为三部分： 其中背景通过shape.xml实现 滑动的锁是一张图片 文字通过Paint绘制在中间，高度可定制 主要介绍一下实现的主要部分:(1)有自定义的属性如下：1234567&lt;declare-styleable name=&quot;SlideLockView&quot;&gt; &lt;attr name=&quot;lock_drawable&quot; format=&quot;reference&quot;/&gt; &lt;attr name=&quot;lock_radius&quot; format=&quot;dimension|reference&quot;/&gt; &lt;attr name=&quot;lock_tips_tx&quot; format=&quot;string|reference&quot;/&gt; &lt;attr name=&quot;locl_tips_tx_size&quot; format=&quot;dimension|reference&quot;/&gt; &lt;attr name=&quot;lock_tips_tx_color&quot; format=&quot;color|reference&quot;/&gt;&lt;/declare-styleable&gt; (2)重写ondraw()方法,绘制文字和锁：12345678910111213141516171819@Overrideprotected void onDraw(Canvas canvas) &#123; canvas.getClipBounds(mTipsTextRect); int cHeight = mTipsTextRect.height(); int cWidth = mTipsTextRect.width(); mPaint.setTextAlign(Paint.Align.LEFT); mPaint.getTextBounds(mTipText, 0, mTipText.length(), mTipsTextRect); float x = cWidth / 2f - mTipsTextRect.width() / 2f - mTipsTextRect.left; float y = cHeight / 2f + mTipsTextRect.height() / 2f - mTipsTextRect.bottom; canvas.drawText(mTipText, x, y, mPaint); int rightMax = getWidth() - mLockRadius * 2; if (mLocationX &lt; 0) &#123; canvas.drawBitmap(mLockBitmap, 0, 0, mPaint); &#125; else if (mLocationX &gt; rightMax) &#123; canvas.drawBitmap(mLockBitmap, rightMax, 0, mPaint); &#125; else &#123; canvas.drawBitmap(mLockBitmap, mLocationX, 0, mPaint); &#125;&#125; (3)最重要的一步是触摸事件的处理,1、当触摸屏幕是触发ACTION_DOWN事件，计算时候触摸到锁，只有当触到锁的时候才能滑动；2、手指移动时，获得新的位置后计算新的位置，然后重新绘制，若移动到另一端表示解锁成功，执行回调方法解锁成功；3、手指离开屏幕后重新reset View,动画回到初始位置：12345678910111213141516171819202122232425262728293031323334353637383940414243@Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; float xPos = event.getX(); float yPos = event.getY(); if (isTouchLock(xPos, yPos)) &#123; mLocationX = xPos - mLockRadius; mIsDragable = true; invalidate(); &#125; else &#123; mIsDragable = false; &#125; return true; &#125; case MotionEvent.ACTION_MOVE: &#123; if (!mIsDragable) return true; int rightMax = getWidth() - mLockRadius * 2; resetLocationX(event.getX(),rightMax); invalidate(); if (mLocationX &gt;= rightMax)&#123; mIsDragable = false; mLocationX = 0; invalidate(); if (mLockListener != null)&#123; mLockListener.onOpenLockSuccess(); &#125; Log.e(&quot;AnimaterListener&quot;,&quot;解锁成功&quot;); &#125; return true; &#125; case MotionEvent.ACTION_UP: &#123; if (!mIsDragable) return true; resetLock(); break; &#125; &#125; return super.onTouchEvent(event); &#125; (4)重新回到初始位置resetLock代码如下:123456789101112private void resetLock()&#123; ValueAnimator anim = ValueAnimator.ofFloat(mLocationX,0); anim.setDuration(300); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; mLocationX = (Float) valueAnimator.getAnimatedValue(); invalidate(); &#125; &#125;); anim.start();&#125; 这就是完成滑动解锁的主要步骤,最后github地址在SlideView]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>滑动解锁</tag>
        <tag>自定义Vied</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SharedPreference和RxJava以及对SharedPreferece添加wrapper]]></title>
    <url>%2F2017%2F06%2F25%2FSharedPreference%E5%92%8CRxJava%E4%BB%A5%E5%8F%8A%E5%AF%B9SharedPreferece%E6%B7%BB%E5%8A%A0wrapper%2F</url>
    <content type="text"><![CDATA[需求分析本文介绍一个SharedPreference的使用的工具类，在Android开发的过程中不可避免的会使用SharedPreference来缓存一个数据，(1)如果频繁使用的话还是最好把存取操作放在子线程去处理；(2)如果不写一个关于SharedPerference的工具类,没法复用很多操作,（3）如果每个对应的业务的数据都写对应的存取删除操作的话，到项目后期会有很多，难以维护； 针对上面的三个问题实现一个比较通用可扩展性强的工具里，SharedPerference支持六种数据：String,Boolean,Int,Long,Float和Set,大部分业务都可以支持，当需要保存Object和List，均可以通过使用Object-&gt;Json-&gt;String再进行保存，SharedPerference是保存在xml文件中键值对，所以有两个重要的属性就是fileName和keyName，所以 SharePerferenceUtil的包含两个内部类：FILE_KEYS和VALUE_KEYS作为索引。1234567891011public class SPUtil &#123; public static final class FILE_KEYS&#123; public static final String APP_STATUS = "app_status"; public static final String USER_INFO = "user_info"; &#125; public static final class VALUE_KEYS&#123; public static final String IS_LOGIN = "is_login"; public static final String USER = "user"; public static final String MOBILE_LOGIN_LIST = "mobile_login_list"; &#125;... 读取成功后的回调接口:123public interface SPResultListener&lt;T&gt; &#123; void onResult(T t);&#125; 当存取List数据时需要Id作为唯一标识，所以Object必须实现接口：123public interface ShareCacheableData &#123; String getId();&#125; 1、首先基本数据类型，以Boolean为例：存数据，调用RxJava使得写操作在I/O线程中进行：1234567891011public static final synchronized void saveBoolean(final String fileKey, final String valueKey, final boolean value)&#123; Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; SharedPreferences sp = OpenEyeApplication.getInstance().getSharedPreferences(fileKey,Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putBoolean(valueKey,value); editor.commit(); &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(); &#125; 读数据,调用RxJava使得读取操作在I/O线程中进行,读取成功后在UI线程中进行的回调:12345678910111213141516171819 public static final void getBoolean(final String fileKey, final String valueKey, final SPResultListener&lt;Boolean&gt; resultListener) &#123; Observable.fromCallable(new Callable&lt;Boolean&gt;() &#123; @Override public Boolean call() throws Exception &#123; SharedPreferences sp = OpenEyeApplication.getInstance().getSharedPreferences(fileKey, Context.MODE_PRIVATE); return sp.getBoolean(valueKey, false); &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Boolean&gt;() &#123; @Override public void call(Boolean value) &#123; value = (value == null) ? false:value; if (resultListener != null) &#123; resultListener.onResult(value); &#125; &#125; &#125;);&#125; 2、存取实体对象，和存取基本的数据多了一个转String的过程，保存实体对象：1234567891011public static final &lt;T extends Serializable&gt; void saveModel(final String fileKey, final String valueKey, final T t)&#123; Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; SharedPreferences sp = OpenEyeApplication.getInstance().getSharedPreferences(fileKey,Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putString(valueKey,new Gson().toJson(t)); editor.commit(); &#125; &#125;).subscribeOn(Schedulers.io()).subscribe();&#125; 读取实体对象： 123456789101112131415161718192021222324public static final &lt;T extends Serializable&gt; void getModel(final String fileKey, final String valueKey, final Class&lt;T&gt; clazz, final SPResultListener&lt;T&gt; resultListener) &#123; Observable.fromCallable(new Callable&lt;T&gt;() &#123; @Override public T call() throws Exception &#123; SharedPreferences sp = OpenEyeApplication.getInstance().getSharedPreferences(fileKey, Context.MODE_PRIVATE); String sResult = sp.getString(valueKey, ""); if (TextUtils.isEmpty(sResult)) &#123; return null; &#125; else &#123; T t = new Gson().fromJson(sResult, clazz); return t; &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;T&gt;() &#123; @Override public void call(T value) &#123; if (resultListener != null) &#123; resultListener.onResult(value); &#125; &#125; &#125;);&#125; 2、存取实体对象列表，Gson转换的时候容易出错，可以特别注意一下：往列表保存对象，ShareCacheableData是为了获取对象的唯一标识：1234567891011121314151617181920212223242526272829public static final &lt;T extends ShareCacheableData&gt; void putList(final String fileKey, final String valueKey, final Class&lt;T[]&gt; clazz, final T t)&#123; Observable.create(new Observable.OnSubscribe&lt;Object&gt;() &#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber) &#123; SharedPreferences sp = OpenEyeApplication.getInstance().getSharedPreferences(fileKey,Context.MODE_PRIVATE); String listJson = sp.getString(valueKey,""); List&lt;T&gt; oldList = new ArrayList&lt;&gt;(); if (!TextUtils.isEmpty(listJson))&#123; T[] array = new Gson().fromJson(listJson,clazz); oldList = new ArrayList&lt;T&gt;(Arrays.asList(array)); &#125; Iterator&lt;T&gt; iterator = oldList.iterator(); while (iterator.hasNext())&#123; T item = iterator.next(); if (TextUtils.equals(item.getId(),t.getId()))&#123; iterator.remove(); &#125; &#125; oldList.add(t); SharedPreferences.Editor editor = sp.edit(); editor.putString(valueKey,new Gson().toJson(oldList)); editor.commit(); subscriber.onStart(); &#125; &#125;).subscribeOn(Schedulers.io()).subscribe(); &#125; 读取对象列表：1234567891011121314151617181920212223242526272829public static final &lt;T extends ShareCacheableData&gt; void getList(final String fileKey, final String valueKey, final Class&lt;T[]&gt; clazz, final SPResultListener&lt;List&lt;T&gt;&gt; resultListener) &#123; Observable.fromCallable(new Callable&lt;List&lt;T&gt;&gt;() &#123; @Override public List&lt;T&gt; call() throws Exception &#123; SharedPreferences sp = OpenEyeApplication.getInstance().getSharedPreferences(fileKey, Context.MODE_PRIVATE); String sResult = sp.getString(valueKey, ""); if (TextUtils.isEmpty(sResult)) &#123; return null; &#125; else &#123; T[] list = new Gson().fromJson(sResult, clazz); return new ArrayList&lt;T&gt;(Arrays.asList(list)); &#125; &#125; &#125;).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;List&lt;T&gt;&gt;() &#123; @Override public void call(List&lt;T&gt; value) &#123; if (resultListener != null) &#123; resultListener.onResult(value); &#125; &#125; &#125;); &#125; 结束了。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SharedPerference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单学习Groovy]]></title>
    <url>%2F2017%2F06%2F24%2F%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0Groovy%2F</url>
    <content type="text"><![CDATA[基于该网站深入理解groovy学习，Android Studio使用gradle工具进行打包编译的，而gradle使用groovy语言编写的，groovy是一种DSL语言，即Domain Specific Language领域相关语言，有很多默认的潜规则，使用起来非常灵活。 Groovy的开发环境在ubuntu上搭建groovy的开发环境还是非常简单的，具体也可以参考官网groovy官网123- curl -s get.gvmtool.net | bash - source "$HOME/.gvm/bin/gvm-init.sh"- gvm install groovy 然后就可以创建一个.groovy文件，比如说test.groovy文件，使用groovy .groovy运行执行，感觉非常像shell脚本似的 Groovy的一些基础知识哦 Groovy的注释标记和java是一样的 Groovy语句可以不用分号结尾，也是减少了代码的输入量啊 Groovy支持动态类型，和很多动态语言是一样的，定义变量的时候不用指定数据类型，但是尽量还是使用def关键字进行声明，虽然不用也是可以的，不过这个还是有坑。。。123def variable1 = 1 //可以不使用分号结尾def varable2 = "I am a person"def int x = 1 //变量定义时，也可以直接指定类型 4.定义函数的时候也是可以不用指定参数的类型的123String function(arg1,arg2)&#123; ...&#125; 函数的返回值也是可以不用指定的，没有指定函数返回值的会根据函数内最用一句的执行结果进行返回，并且使用def进行声明，举个栗子：1234567def fuction1()&#123; ... lastLine&#125;String fuction2()&#123; return "the returned String"&#125; 5.Groovy对字符串的支持是非常强大的，不过还是有几个规则使用的方法 单引号中的内容是严格的字符串，不会对$中的变量进行转义， 双引号的字符串内容会对$表达式进行求值转义 Groovy还是三个引号，如果是三个引号的话就可以任意的换行了12345678def singleQuote='I am $ dolloar' //输出就是I am $ dolloardef doubleQuoteWithoutDollar = "I am one dollar" //输出 I am one dollardef x = 1def doubleQuoteWithDollar = "I am $x dolloar" //输出I am 1 dolloardef multieLines = ''' begin line 1 line 2 end ''' Groovy中的数据类型在java的基本数据类型都已经被groovy包装成对象，只有对象啦。。。 Groovy容器类 List链表，对应的Java中的List接口，一般是用ArrayList作为真正的实现类 Map键值表，其底层对应的是Java中的LinkedHashMap Range，基于List实现的一种扩展 List 12345678910变量定义：List变量由[]定义，比如def aList = [5,'string',true] //List由[]定义，其元素可以是任何对象变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List会自动往该索引添加元素assert aList[1] == 'string'assert aList[5] == null //第6个元素为空aList[100] = 100 //设置第101个元素的值为10assert aList[100] == 100那么，aList到现在为止有多少个元素呢？println aList.size ===&gt;结果是101 Map 123456789101112131415容器变量定义变量定义：Map变量由[:]定义，比如def aMap = ['key1':'value1','key2':true] Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用''或""包起来，也可以不用引号包起来。比如def aNewMap = [key1:"value",key2:true] //其中的key1和key2默认被处理成字符串"key1"和"key2"不过Key要是不使用引号包起来的话，也会带来一定混淆，比如def key1="wowo"def aConfusedMap=[key1:"who am i?"]aConfuseMap中的key1到底是"key1"还是变量key1的值“wowo”？显然，答案是字符串"key1"。如果要是"wowo"的话，则aConfusedMap的定义必须设置成：def aConfusedMap=[(key1):"who am i?"]Map中元素的存取更加方便，它支持多种方法：println aMap.keyName &lt;==这种表达方法好像key就是aMap的一个成员变量一样println aMap['keyName'] &lt;==这种表达方法更传统一点aMap.anotherkey = "i am map" &lt;==为map添加新元素 Range类 123456def aRange = 1..5 &lt;==Range类型的变量 由begin值+两个点+end值表示 左边这个aRange包含1,2,3,4,5这5个值如果不想包含最后一个元素，则def aRangeWithoutEnd = 1..&lt;5 &lt;==包含1,2,3,4这4个元素println aRange.fromprintln aRange.to Groovy的闭包闭包是一个非常牛逼哄哄的东西，做iOS开发的应该不会默认，太方便了额，闭包，是一种数据类型，它代表了一段可执行的代码。在Groovy中定义格式是这样的1234567891011def xxx = &#123;paramters -&gt; code&#125; //或者 def xxx = &#123;无参数，纯code&#125; //这种case不需要-&gt;符号def aClosure = &#123;//闭包是一段代码，所以需要用花括号括起来.. String param1, int param2 -&gt; //这个箭头很关键。箭头前面是参数定义，箭头后面是代码 println"this is code" //这是代码，最后一句是返回值， //也可以使用return，和Groovy中普通函数一样 &#125; //调用aClosure.call("this is string",100) //或者 aClosure("this is string", 100) 如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。 each函数调用的圆括号不见了！原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。12345678def testClosure(int a1,String b1, Closure closure)&#123; //do something closure() //调用闭包&#125;那么调用的时候，就可以免括号！testClosure (4, "test", &#123; println "i am in closure"&#125; ) //红色的括号可以不写.. 脚本类、文件I/O和XML操作脚本中的变量和作用域文件的I/O操作groovy的I/O操作在原有Java的基础上进行了更为简便的封装 读文件123456789101112131415161718192021def targetFile = new File(文件名); //&lt;==File对象还是要创建的。//直接得到文件内容targetFile.getBytes() //&lt;==文件内容一次性读出，返回类型为byte[] //使用InputStream.InputStreamdef ism = targetFile.newInputStream() //操作ism，最后记得关掉 ism.close //使用闭包操作inputStream targetFile.withInputStream&#123; ism -&gt; //操作ism.不用close。Groovy会自动替你close&#125;//写文件和读文件一样def srcFile = new File(源文件名) def targetFile = new File(目标文件名) targetFile.withOutputStream&#123; os-&gt; srcFile.withInputStream&#123; ins-&gt; os &lt;&lt; ins //利用OutputStream的&lt;&lt;操作符重载，完成从inputstream到OutputStream //的输出 &#125; &#125; // XML操作除了I/O异常简单之外，Groovy中的XML操作也极致得很。Groovy中，XML的解析提供了和XPath类似的方法，名为GPath。这是一个类，提供相应API。关于XPath，请看Wiki。GPath功能包括：给个例子好了，来自Groovy官方文档 test.xml文件：12345678910111213141516171819202122&lt;response version-api="2.0"&gt; &lt;value&gt; &lt;books&gt; &lt;book available="20" id="1"&gt; &lt;title&gt;Don Xijote&lt;/title&gt; &lt;author id="1"&gt;Manuel De Cervantes&lt;/author&gt; &lt;/book&gt; &lt;book available="14" id="2"&gt; &lt;title&gt;Catcher in the Rye&lt;/title&gt; &lt;author id="2"&gt;JD Salinger&lt;/author&gt; &lt;/book&gt; &lt;book available="13" id="3"&gt; &lt;title&gt;Alice in Wonderland&lt;/title&gt; &lt;author id="3"&gt;Lewis Carroll&lt;/author&gt; &lt;/book&gt; &lt;book available="5" id="4"&gt; &lt;title&gt;Don Xijote&lt;/title&gt; &lt;author id="4"&gt;Manuel De Cervantes&lt;/author&gt; &lt;/book&gt; &lt;/books&gt; &lt;/value&gt; &lt;/response&gt; groovy解析 123456789101112131415161718192021222324//第一步，创建XmlSlurper类 def xparser = new XmlSlurper() def targetFile = new File("test.xml") //轰轰的GPath出场 GPathResult gpathResult =xparser.parse(targetFile) //开始玩test.xml。现在我要访问id=4的book元素。 //下面这种搞法，gpathResult代表根元素response。通过e1.e2.e3这种 //格式就能访问到各级子元素.... def book4 = gpathResult.value.books.book[3] //得到book4的author元素 def author = book4.author //再来获取元素的属性和textvalue assert author.text() == ' Manuel De Cervantes ' //获取属性更直观 author.@id == '4' //或者author['@id'] == '4' //属性一般是字符串，可通过toInteger转换成整数 author.@id.toInteger() == 4 //好了。GPath就说到这。再看个例子。我在使用Gradle的时候有个需求，就是获取AndroidManifest.xml版本号（versionName）。有了GPath，一行代码搞定，请看： def androidManifest = newXmlSlurper().parse("AndroidManifest.xml") println androidManifest['@android:versionName'] //或者 println androidManifest.@'android:versionName' 学习自InfoQ]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Groovy</tag>
      </tags>
  </entry>
</search>
